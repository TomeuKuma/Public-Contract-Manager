import { useMemo, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle, CardDescription } from "@/components/ui/card";
import { supabase } from "@/integrations/supabase/client";
import {
    BarChart,
    Bar,
    XAxis,
    YAxis,
    CartesianGrid,
    Tooltip,
    ResponsiveContainer,
    Cell,
} from "recharts";
import { CPVFiltersState } from "./CPVFilters";
import { useQuery } from "@tanstack/react-query";
import { ArrowUpDown, ArrowDown, ArrowUp } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Slider } from "@/components/ui/slider";
import { Label } from "@/components/ui/label";

// Function to get color based on CPV division (2 first digits)
// Using a professional blue-gray palette coherent with the project theme
const getCPVColor = (code: string): string => {
    // Extract first 2 digits to get the division
    const division = parseInt(code.substring(0, 2));

    // Use a more subtle color palette based on blue-gray tones
    // Different divisions get different hues in the blue-cyan-teal range
    const baseHue = 200; // Start with blue
    const hueRange = 80; // Span from blue to teal
    const hue = baseHue + (division * hueRange / 100);
    const saturation = 45 + (division % 3) * 10; // Vary saturation slightly
    const lightness = 50 + (division % 5) * 5; // Vary lightness slightly

    return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
};

interface CPVAnalysisProps {
    filters: CPVFiltersState;
}

const CPVAnalysis = ({ filters }: CPVAnalysisProps) => {
    const [sortBy, setSortBy] = useState<"amount_desc" | "amount_asc" | "code_asc">("amount_desc");
    const [topN, setTopN] = useState<number>(10);

    const { data: rawData, isLoading, error: queryError } = useQuery({
        queryKey: ['cpv-analysis'],
        queryFn: async () => {
            console.log("Fetching CPV analysis data...");

            // Base query to fetch lots with credits and CPV info
            const { data, error } = await supabase
                .from('lots')
                .select(`
                    id,
                    contract_id,
                    cpv,
                    cpv_codes (
                        code,
                        description:description_ca,
                        division,
                        group_code,
                        class_code,
                        category_code
                    ),
                    credits (
                        amount:credit_committed_d,
                        year:any
                    ),
                    contracts (
                        contracting_body,
                        contract_type,
                        award_procedure
                    )
                `);

            if (error) {
                console.error("Error fetching CPV data:", error);
                throw error;
            }

            console.log("CPV data fetched:", data?.length, "lots");
            return data;
        }
    });

    // Process and aggregate data
    const processedData = useMemo(() => {
        if (!rawData) return [];

        const aggMap = new Map<string, {
            code: string;
            description: string;
            label: string;
            yAxisLabel: string;
            amount: number;
            count: number;
        }>();

        console.log("First lot sample:", rawData[0]);
        console.log("Processing", rawData.length, "lots with filters:", filters);

        rawData.forEach((lot: any) => {
            // 1. Filter by Year
            const lotCredits = lot.credits || [];

            // When years filter is empty, include ALL credits. Otherwise, filter by year.
            const validCredits = filters.years.length === 0
                ? lotCredits
                : lotCredits.filter((c: any) => filters.years.includes(String(c.year)));

            if (validCredits.length === 0) return; // Skip if no credits match year filter

            // 2. Filter by Contracting Body
            const contractingBody = lot.contracts?.contracting_body;
            if (filters.contractingBodies.length > 0 && !filters.contractingBodies.includes(contractingBody)) {
                return;
            }

            // 3. Filter by Contract Type
            const contractType = lot.contracts?.contract_type;
            if (filters.contractTypes.length > 0 && !filters.contractTypes.includes(contractType)) {
                return;
            }

            // 4. Filter by Award Procedure
            const awardProcedure = lot.contracts?.award_procedure;
            if (filters.awardProcedures.length > 0 && !filters.awardProcedures.includes(awardProcedure)) {
                return;
            }

            // 5. Filter by selected CPV (if any)
            const cpvData = lot.cpv_codes;
            if (!cpvData) return;

            if (filters.cpv) {
                // If a CPV is selected, only include lots that belong to this CPV or its children
                if (!cpvData.code.startsWith(filters.cpv.code)) {
                    return;
                }
            }

            const totalAmount = validCredits.reduce((sum: number, c: any) => sum + (c.amount || 0), 0);

            let aggCode = cpvData.code;
            let aggDesc = cpvData.description;
            let levelLabel = 'Codi';

            // Determine aggregation key
            if (filters.cpv) {
                // If CPV selected, aggregate by immediate children
                // Logic: Find the next level of granularity relative to the selected CPV
                // Example: Selected 45000000 (Division), aggregate by Group (3 digits)
                // Example: Selected 45200000 (Group), aggregate by Class (4 digits)

                const selectedCode = filters.cpv.code;
                // Clean trailing zeros to determine "real" length of selected code
                const significantLength = selectedCode.replace(/0+$/, '').length;

                // Determine next level length. 
                // Division (2) -> Group (3) -> Class (4) -> Category (5) -> Detailed (8)
                let nextLevelLength = 8;
                if (significantLength < 2) nextLevelLength = 2;
                else if (significantLength < 3) nextLevelLength = 3;
                else if (significantLength < 4) nextLevelLength = 4;
                else if (significantLength < 5) nextLevelLength = 5;

                // If the lot's code is exactly the selected code, it goes into a "Propis" bucket or similar, 
                // or we just use its full code if we can't break it down further.
                // For now, let's try to aggregate by the next level.

                if (cpvData.code === selectedCode) {
                    // It's the code itself.
                    aggCode = cpvData.code;
                    aggDesc = cpvData.description;
                } else {
                    // It's a child. Truncate to next level.
                    // Note: This simple truncation relies on CPV structure.
                    // We might need to look up the description for the truncated code if we want it perfect.
                    // For now, use the lot's description or "Varios" if we aggregate multiple.
                    // Actually, to get the description of the parent group/class, we'd need a lookup.
                    // Since we don't have a full CPV tree loaded, we might have to stick to the code
                    // or use the lot's description if it happens to match the group (unlikely).

                    // Alternative: Use the fields from the join if available (division, group_code, etc)
                    // The query joins cpv_codes, so we have: division, group_code, class_code, category_code.

                    if (nextLevelLength === 2) {
                        aggCode = cpvData.division || cpvData.code.substring(0, 2);
                        levelLabel = 'Divisió';
                    } else if (nextLevelLength === 3) {
                        aggCode = cpvData.group_code || cpvData.code.substring(0, 3);
                        levelLabel = 'Grup';
                    } else if (nextLevelLength === 4) {
                        aggCode = cpvData.class_code || cpvData.code.substring(0, 4);
                        levelLabel = 'Classe';
                    } else if (nextLevelLength === 5) {
                        aggCode = cpvData.category_code || cpvData.code.substring(0, 5);
                        levelLabel = 'Categoria';
                    } else {
                        aggCode = cpvData.code;
                        levelLabel = 'Detall';
                    }

                    // We don't have the description for the aggregated code easily available if it's not the lot's exact code.
                    // We will use the code as description for now, or try to find a representative description.
                    // In a real scenario, we'd need to fetch the description for 'aggCode'.
                    // For this implementation, let's use the code and maybe "(Agregat)"
                    if (aggCode !== cpvData.code) {
                        aggDesc = `(Agregat) ${aggCode}`;
                        // Ideally we would fetch the description for this group code.
                    }
                }

            } else {
                // Standard hierarchy aggregation (existing logic)
                if (filters.hierarchyLevel !== 'detailed') {
                    switch (filters.hierarchyLevel) {
                        case '2': // Division
                            aggCode = cpvData.division || cpvData.code.substring(0, 2);
                            aggDesc = cpvData.description; // This description might be wrong for the group!
                            // Fix: We really should try to get the description for the division.
                            // But we don't have it. We'll stick to the current behavior which seems to use the lot's description.
                            // Wait, if we aggregate, we sum up amounts. The description should be for the group.
                            // The previous code was: aggDesc = cpvData.description;
                            // This means the description of the LAST processed lot in the group overwrites the others?
                            // Or the first? Map.set overwrites if we don't check existence.
                            // The previous code checked existence: if (aggMap.has) ... else set.
                            // So it keeps the description of the FIRST lot encountered for that group.
                            // This is not ideal but acceptable if we assume the first lot is representative or we don't have better data.
                            levelLabel = 'Divisió';
                            break;
                        case '3': // Group
                            aggCode = cpvData.group_code || cpvData.code.substring(0, 3);
                            aggDesc = cpvData.description;
                            levelLabel = 'Grup';
                            break;
                        case '4': // Class
                            aggCode = cpvData.class_code || cpvData.code.substring(0, 4);
                            aggDesc = cpvData.description;
                            levelLabel = 'Classe';
                            break;
                        case '5': // Category
                            aggCode = cpvData.category_code || cpvData.code.substring(0, 5);
                            aggDesc = cpvData.description;
                            levelLabel = 'Categoria';
                            break;
                    }
                }
            }

            if (aggMap.has(aggCode)) {
                const existing = aggMap.get(aggCode)!;
                existing.amount += totalAmount;
                existing.count += 1;
            } else {
                aggMap.set(aggCode, {
                    code: aggCode,
                    description: aggDesc, // Note: This might be the description of a child, not the group itself.
                    label: `${aggCode} - ${aggDesc}`,
                    yAxisLabel: `${levelLabel} ${aggCode}`,
                    amount: totalAmount,
                    count: 1
                });
            }
        });

        let result = Array.from(aggMap.values());

        // Sort
        result.sort((a, b) => {
            if (sortBy === 'amount_asc') return a.amount - b.amount;
            if (sortBy === 'code_asc') return a.code.localeCompare(b.code);
            return b.amount - a.amount; // Default: amount_desc
        });

        // Top N
        return result.slice(0, topN);
    }, [rawData, filters, sortBy, topN]);

    console.log("Processed data:", processedData.length, "items");

    if (isLoading) {
        return <div className="flex items-center justify-center h-64">Carregant dades...</div>;
    }

    if (queryError) {
        return (
            <div className="flex items-center justify-center h-64 text-red-600">
                Error carregant dades: {queryError instanceof Error ? queryError.message : 'Error desconegut'}
            </div>
        );
    }

    if (!rawData || rawData.length === 0) {
        return (
            <div className="flex items-center justify-center h-64 text-muted-foreground">
                No hi ha dades disponibles.
            </div>
        );
    }

    if (processedData.length === 0) {
        return (
            <div className="flex items-center justify-center h-64 text-muted-foreground">
                No hi ha dades que coincideixin amb els filtres seleccionats.
            </div>
        );
    }

    return (
        <div className="space-y-6">
            <Card>
                <CardHeader>
                    <div className="flex flex-col gap-4">
                        <div className="flex items-center justify-between">
                            <div>
                                <CardTitle>Crèdit compromès per codi CPV</CardTitle>
                                <CardDescription>
                                    {filters.cpv
                                        ? `Anàlisi del CPV ${filters.cpv.code} - ${filters.cpv.description_ca}`
                                        : "Anàlisi dels imports adjudicats agrupats per codi CPV"
                                    }
                                    {filters.years.length > 0 && ` (Anys: ${filters.years.join(', ')})`}
                                </CardDescription>
                            </div>
                            <div className="flex gap-1">
                                <Button
                                    variant={sortBy === 'amount_desc' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => setSortBy('amount_desc')}
                                    className="gap-1"
                                >
                                    <ArrowDown className="h-3 w-3" />
                                    Import
                                </Button>
                                <Button
                                    variant={sortBy === 'amount_asc' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => setSortBy('amount_asc')}
                                    className="gap-1"
                                >
                                    <ArrowUp className="h-3 w-3" />
                                    Import
                                </Button>
                                <Button
                                    variant={sortBy === 'code_asc' ? 'default' : 'outline'}
                                    size="sm"
                                    onClick={() => setSortBy('code_asc')}
                                    className="gap-1"
                                >
                                    <ArrowUpDown className="h-3 w-3" />
                                    Codi
                                </Button>
                            </div>
                        </div>

                        {/* Top N Slider moved here */}
                        <div className="flex items-center gap-4 bg-muted/30 p-3 rounded-md">
                            <Label className="whitespace-nowrap min-w-[100px]">Mostrar Top {topN}</Label>
                            <Slider
                                value={[topN]}
                                onValueChange={(vals) => setTopN(vals[0])}
                                min={5}
                                max={50}
                                step={5}
                                className="w-full max-w-[300px]"
                            />
                        </div>
                    </div>
                </CardHeader>
                <CardContent>
                    <div className="h-[500px] w-full">
                        <ResponsiveContainer width="100%" height="100%">
                            <BarChart
                                data={processedData}
                                layout="vertical"
                                margin={{ top: 5, right: 30, left: 20, bottom: 5 }}
                            >
                                <CartesianGrid strokeDasharray="3 3" horizontal={false} />
                                <XAxis
                                    type="number"
                                    tickFormatter={(value) => `${(value / 1000000).toFixed(1)}M€`}
                                    tick={{ fontSize: 12, fill: '#64748b' }}
                                />
                                <YAxis
                                    type="category"
                                    dataKey="yAxisLabel"
                                    width={120}
                                    tick={{ fontSize: 11, fill: '#64748b' }}
                                />
                                <Tooltip
                                    content={({ active, payload }) => {
                                        if (active && payload && payload.length) {
                                            const data = payload[0].payload;
                                            return (
                                                <div className="bg-white p-4 border rounded shadow-lg max-w-[400px]">
                                                    <p className="font-bold text-lg mb-1">{data.code}</p>
                                                    <p className="text-sm text-gray-600 mb-2">{data.description}</p>
                                                    <div className="flex justify-between items-center border-t pt-2">
                                                        <span className="font-semibold">Import Total:</span>
                                                        <span className="text-lg text-blue-600 font-bold">
                                                            {new Intl.NumberFormat('ca-ES', { style: 'currency', currency: 'EUR' }).format(data.amount)}
                                                        </span>
                                                    </div>
                                                    <div className="text-xs text-gray-500 mt-1">
                                                        {data.count} contracte(s)
                                                    </div>
                                                </div>
                                            );
                                        }
                                        return null;
                                    }}
                                />
                                <Bar dataKey="amount" radius={[0, 4, 4, 0]} name="Import">
                                    {processedData.map((entry, index) => (
                                        <Cell key={`cell-${index}`} fill={getCPVColor(entry.code)} />
                                    ))}
                                </Bar>
                            </BarChart>
                        </ResponsiveContainer>
                    </div>
                </CardContent>
            </Card>
        </div>
    );
};

export default CPVAnalysis;
