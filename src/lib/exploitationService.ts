import { supabase } from "@/integrations/supabase/client";
import { CPVCode } from "@/types/cpv.types";
import { CONTRACTING_BODIES } from "@/lib/constants";

export type NeedType = "Puntual" | "Recurrent";

export interface FractionationFilters {
    contractingBodies: string[];
    needType: NeedType;
    cpv: CPVCode | null;
}

export interface FractionationResult {
    contracting_body: string;
    total_committed: number;
}

/**
 * Get unique contracting bodies from constants (same as contract form)
 */
export const getContractingBodies = async (): Promise<string[]> => {
    return [...CONTRACTING_BODIES];
};

/**
 * Get fractionation data based on filters
 */
export const getFractionationData = async (
    filters: FractionationFilters
): Promise<FractionationResult[]> => {
    try {
        const { contractingBodies, needType, cpv } = filters;

        if (!cpv || contractingBodies.length === 0) {
            return [];
        }

        // Calculate date range based on need type
        const currentYear = new Date().getFullYear();
        const startYear = needType === "Puntual" ? currentYear : currentYear - 5;

        // Query credits with joins to lots and contracts
        let query = supabase
            .from("credits")
            .select(`
        credit_committed_d,
        any,
        lot:lots!inner(
          cpv_code_id,
          contract:contracts!inner(
            contracting_body
          )
        )
      `);

        // Filter by contracting bodies
        query = query.in("lot.contract.contracting_body", contractingBodies);

        // Filter by exact CPV
        if (cpv) {
            query = query.eq("lot.cpv_code_id", cpv.id);
        }

        // Filter by year range
        query = query.gte("any", startYear).lte("any", currentYear);

        const { data, error } = await query;

        if (error) throw error;

        // Aggregate by contracting body
        const aggregated = (data || []).reduce((acc: Record<string, number>, row: any) => {
            const body = row.lot?.contract?.contracting_body;
            if (body) {
                acc[body] = (acc[body] || 0) + (row.credit_committed_d || 0);
            }
            return acc;
        }, {});

        // Convert to array format
        const results: FractionationResult[] = Object.entries(aggregated).map(
            ([contracting_body, total_committed]) => ({
                contracting_body,
                total_committed: total_committed as number,
            })
        );

        return results.sort((a, b) => b.total_committed - a.total_committed);
    } catch (error) {
        console.error("Error fetching fractionation data:", error);
        return [];
    }
};
