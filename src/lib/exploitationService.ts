/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Exploitation Service
 * 
 * Uses 'any' for Supabase query results with complex nested joins.
 */
import { supabase } from "@/integrations/supabase/client";
import { CPVCode } from "@/types/cpv.types";
import { CONTRACTING_BODIES } from "@/lib/constants";

export type NeedType = "Puntual" | "Recurrent";

export interface FractionationFilters {
    contractingBodies: string[];
    needType: NeedType;
    cpv: CPVCode | null;
}

export interface FractionationResult {
    contracting_body: string;
    total_committed: number;
}

/**
 * Get unique contracting bodies from constants (same as contract form)
 */
export const getContractingBodies = async (): Promise<string[]> => {
    return [...CONTRACTING_BODIES];
};

/**
 * Get fractionation data based on filters
 */
export const getFractionationData = async (
    filters: FractionationFilters
): Promise<FractionationResult[]> => {
    try {
        const { contractingBodies, needType, cpv } = filters;

        if (!cpv || contractingBodies.length === 0) {
            return [];
        }

        // Calculate date range based on need type
        const currentYear = new Date().getFullYear();
        const startYear = needType === "Puntual" ? currentYear : currentYear - 5;

        // Query credits with joins to lots and contracts
        let query = supabase
            .from("credits")
            .select(`
        credit_committed_d,
        any,
        lot:lots!inner(
          cpv_code_id,
          contract:contracts!inner(
            contracting_body
          )
        )
      `);

        // Filter by contracting bodies
        query = query.in("lot.contract.contracting_body", contractingBodies);

        // Filter by exact CPV
        if (cpv) {
            query = query.eq("lot.cpv_code_id", cpv.id);
        }

        // Filter by year range
        query = query.gte("any", startYear).lte("any", currentYear);

        const { data, error } = await query;

        if (error) throw error;

        // Aggregate by contracting body
        const aggregated = (data || []).reduce((acc: Record<string, number>, row: any) => {
            const body = row.lot?.contract?.contracting_body;
            if (body) {
                acc[body] = (acc[body] || 0) + (row.credit_committed_d || 0);
            }
            return acc;
        }, {});

        // Convert to array format
        const results: FractionationResult[] = Object.entries(aggregated).map(
            ([contracting_body, total_committed]) => ({
                contracting_body,
                total_committed: total_committed as number,
            })
        );

        return results.sort((a, b) => b.total_committed - a.total_committed);
    } catch (error) {
        console.error("Error fetching fractionation data:", error);
        return [];
    }
};

export interface FractionationDetail {
    lot_id: string;
    lot_name: string;
    contracting_body: string;
    file_number: string;
    credits: {
        id: string;
        amount: number;
        recognized: number;
        real: number;
        year: number;
        organic: string;
        program: string;
        economic: string;
        invoices: {
            id: string;
            number: string;
            date: string;
            amount: number;
        }[];
    }[];
}

export const getFractionationDetails = async (
    filters: FractionationFilters
): Promise<FractionationDetail[]> => {
    try {
        const { contractingBodies, needType, cpv } = filters;

        if (!cpv || contractingBodies.length === 0) {
            return [];
        }

        const currentYear = new Date().getFullYear();
        const startYear = needType === "Puntual" ? currentYear : currentYear - 5;

        const query = supabase
            .from("lots")
            .select(`
                id,
                name,
                contract:contracts!inner(
                    contracting_body,
                    file_number
                ),
                credits(
                    id,
                    credit_committed_d,
                    credit_recognized_o,
                    credit_real,
                    any,
                    organic_item,
                    program_item,
                    economic_item,
                    invoices(
                        id,
                        invoice_number,
                        invoice_date,
                        total
                    )
                )
            `)
            .eq("cpv_code_id", cpv.id)
            .in("contract.contracting_body", contractingBodies);

        const { data, error } = await query;

        if (error) throw error;

        // Filter credits by year range client-side since we can't easily filter nested array in select
        // and we want to keep the lot if it has ANY relevant credits?
        // Actually, the previous logic filtered credits by year.
        // Let's filter the results to only include credits within the year range.

        const results: FractionationDetail[] = (data || [])
            .map((lot: any) => {
                const validCredits = (lot.credits || []).filter((credit: any) =>
                    credit.any >= startYear && credit.any <= currentYear
                );

                if (validCredits.length === 0) return null;

                return {
                    lot_id: lot.id,
                    lot_name: lot.name,
                    contracting_body: lot.contract?.contracting_body || "",
                    file_number: lot.contract?.file_number || "",
                    credits: validCredits.map((credit: any) => ({
                        id: credit.id,
                        amount: credit.credit_committed_d,
                        recognized: credit.credit_recognized_o || 0,
                        real: credit.credit_real || 0,
                        year: credit.any,
                        organic: credit.organic_item || "",
                        program: credit.program_item || "",
                        economic: credit.economic_item || "",
                        invoices: (credit.invoices || []).map((inv: any) => ({
                            id: inv.id,
                            number: inv.invoice_number,
                            date: inv.invoice_date,
                            amount: inv.total
                        }))
                    }))
                };
            })
            .filter((item): item is FractionationDetail => item !== null);

        return results;
    } catch (error) {
        console.error("Error fetching fractionation details:", error);
        return [];
    }
};
